# Chapter 5: Хранилище и модель результата теста


В [предыдущей главе](04_функции_обогащения_результатов_.md) мы научились обогащать наши тесты, добавляя к ним сообщения, ссылки и вложения с помощью функций `addMessage`, `addLink` и `addAttachment`. Но куда вся эта информация (вместе с результатами шагов, общим статусом теста и его метаданными) складывается *до того*, как будет отправлена в Test IT? Как адаптер собирает полную картину по каждому тесту?

Представьте, что вы заполняете анкету о проделанной работе. Вы не отправляете каждый ответ сразу после записи, а сначала заполняете все пункты, прикрепляете нужные документы, и только потом отправляете готовую анкету. `adapters-flutter` работает похожим образом. Ему нужно место, где можно временно хранить всю информацию о текущем тесте — своеобразная "анкета" — пока тест не завершится. Вот здесь и вступают в игру **Хранилище (`TestResultStorage`)** и **Модель результата теста (`TestResultModel`)**.

## Зачем нужно временное хранилище?

Когда выполняется тест (`tmsTest` или `tmsTestWidgets`), события происходят последовательно:
1.  Тест начинается.
2.  Выполняется шаг 1.
3.  Выполняется шаг 2 (возможно, с вложением).
4.  Происходит ошибка.
5.  Тест завершается с результатом "Провален".

Было бы неэффективно отправлять в Test IT отдельный отчет после каждого шага или добавления вложения. Гораздо лучше собрать *всю* информацию об одном тесте — его название, идентификатор (`externalId`), все шаги со статусами, все вложения, сообщения, ссылки, итоговый результат (`Passed`, `Failed`, `Skipped`) — в одном месте, а затем отправить этот полный отчет целиком после завершения теста.

Именно для этого и нужны `TestResultModel` и `TestResultStorage`:
*   **`TestResultModel`:** Это структура данных, та самая "анкета" или "карточка" для *одного* конкретного теста. Она содержит поля для всей информации, которую мы можем захотеть отправить в Test IT.
*   **`TestResultStorage`:** Это временное хранилище, как "картотека" или "папка на рабочем столе", где хранятся *все* "анкеты" (`TestResultModel`) для тестов, которые выполняются прямо сейчас или только что завершились, но еще не были отправлены.

## `TestResultModel`: Анкета для вашего теста

`TestResultModel` — это Dart-класс, который служит шаблоном для сбора данных о тесте. Думайте о нем как о пустой анкете со множеством полей:

*   `externalId`: Уникальный ID теста для связи с Test IT.
*   `title`: Заголовок теста.
*   `description`: Описание теста.
*   `outcome`: Итоговый результат (`Passed`, `Failed`, `Skipped`).
*   `steps`: Список выполненных [шагов теста](03_управление_шагами_теста_.md), каждый со своим результатом и деталями.
*   `attachments`: Список [вложений](04_функции_обогащения_результатов_.md) (точнее, их ID после загрузки).
*   `links`: Набор добавленных [ссылок](04_функции_обогащения_результатов_.md).
*   `message`: Добавленные [текстовые сообщения](04_функции_обогащения_результатов_.md).
*   `startedOn`, `completedOn`, `duration`: Время начала, окончания и длительность теста.
*   `traces`: Текст ошибки и стек вызовов (если тест упал).
*   `workItemIds`: ID связанных рабочих элементов (work items) в Test IT.
*   ...и другие поля (`namespace`, `classname`, `methodName`, `labels`, `parameters`).

Когда запускается `tmsTest` или `tmsTestWidgets`, для него создается пустой экземпляр `TestResultModel`. По мере выполнения теста и его шагов, а также при вызове функций вроде `step`, `addAttachment`, `addLink`, `addMessage`, соответствующие поля в этом экземпляре `TestResultModel` заполняются или обновляются.

Вот как (очень упрощенно) может выглядеть структура этого класса в коде:

```dart
// Упрощенное представление класса TestResultModel
// Находится в: lib/src/model/test_result_model.dart

@internal // Пометка, что класс для внутреннего использования
final class TestResultModel {
  // Основные данные теста
  String? externalId;
  String? title;
  String? description;
  Outcome? outcome; // Результат (Passed, Failed, Skipped)

  // Время выполнения
  DateTime? startedOn;
  DateTime? completedOn;
  int? duration; // в миллисекундах

  // Собранные данные
  List<AutoTestStepResultsModel> steps = []; // Список шагов
  List<AttachmentPutModel> attachments = []; // Список ID вложений
  Set<Link> links = {}; // Набор ссылок
  String? message; // Сообщения (объединенные)
  String? traces; // Текст ошибки

  Set<String> workItemIds = {}; // Связанные задачи

  // ... другие поля (namespace, classname, etc.) ...
}
```

**Пояснение:**
*   Этот класс просто содержит поля для хранения всех нужных данных.
*   Обратите внимание, что `steps` — это список других моделей (`AutoTestStepResultsModel`), так как шаги сами могут содержать свои детали. Аналогично для `attachments` и `links`.

## `TestResultStorage`: Картотека для анкет

Если `TestResultModel` — это одна анкета, то `TestResultStorage` — это место, где хранятся все эти анкеты во время выполнения тестов. Это внутренний компонент адаптера, который обычно реализован как *in-memory* хранилище (данные хранятся в оперативной памяти, пока работает процесс тестов).

Основные задачи `TestResultStorage`:
1.  **Создавать место для нового теста:** Когда начинается `tmsTest`, хранилище создает "запись" или "слот" для него, ассоциируя его с уникальным идентификатором теста (обычно на основе пути к файлу и имени теста).
2.  **Хранить `TestResultModel`:** В этом слоте хранится экземпляр `TestResultModel` для данного теста.
3.  **Обновлять данные:** Когда вызываются `step`, `addAttachment` и т.д., `TestResultStorage` находит нужный `TestResultModel` по ID теста (или текущего шага) и обновляет в нем соответствующие поля (добавляет шаг, ссылку, сообщение, ID вложения, обновляет статус).
4.  **Предоставлять готовые результаты:** Когда тест завершается, его полная "анкета" (`TestResultModel`) извлекается из хранилища для последующей отправки в Test IT (этим занимается [Взаимодействие с API Test IT](06_взаимодействие_с_api_test_it_.md)).
5.  **Обрабатывать `setUpAll`/`tearDownAll`:** Хранилище также умеет связывать шаги из `setUpAll` и `tearDownAll` с соответствующими тестами группы.

Думайте о `TestResultStorage` как о секретаре, который держит на столе папки для каждого текущего дела (теста). Когда приходит новая информация (результат шага, ссылка), секретарь находит нужную папку и подшивает туда документ или делает пометку. Когда дело завершено, папка передается дальше на отправку.

## Как это работает вместе: Жизненный цикл данных теста

Давайте проследим, как `TestResultModel` и `TestResultStorage` взаимодействуют во время выполнения простого теста:

```dart
// Пример теста
tmsTest('Мой простой тест', () async {
  await step('Шаг 1: Сделать что-то', () {
    expect(true, isTrue);
  });

  await addMessage('Промежуточное сообщение');

  await step('Шаг 2: Сделать что-то еще', () {
    // ...
  });
}); // Тест завершен
```

1.  **Начало `tmsTest('Мой простой тест', ...)`:**
    *   Адаптер определяет уникальный ID для этого теста (например, `path/to/test_file.dart_Мой простой тест`).
    *   Вызывается `TestResultStorage.createEmptyTestResultAsync()`.
    *   `TestResultStorage` создает в своей "картотеке" (внутренней `Map`) запись для этого ID и помещает туда пустой `TestResultModel`.

2.  **Начало `step('Шаг 1: ...')`:**
    *   Вызывается `TestResultStorage.createEmptyStepAsync()`.
    *   `TestResultStorage` находит `TestResultModel` по ID текущего теста.
    *   В список `steps` этого `TestResultModel` добавляется пустая "заготовка" для шага.

3.  **Завершение `step('Шаг 1: ...')` (успешно):**
    *   Вызывается `TestResultStorage.updateCurrentStepAsync()` с данными шага (название, статус `Passed`, время).
    *   `TestResultStorage` находит последнюю добавленную "заготовку" шага в `TestResultModel` и заполняет ее данными.

4.  **Вызов `addMessage('Промежуточное сообщение')`:**
    *   Вызывается `TestResultStorage.updateTestResultMessageAsync()`.
    *   `TestResultStorage` находит `TestResultModel` теста и добавляет сообщение в поле `message`.

5.  **Начало и завершение `step('Шаг 2: ...')`:**
    *   Аналогично шагам 2 и 3, в `TestResultModel` добавляется и заполняется информацией второй шаг.

6.  **Завершение `tmsTest`:**
    *   Тело теста выполнено. Адаптер записывает финальный статус (`Passed`), время окончания, длительность.
    *   Вызывается `TestResultStorage.updateTestResultAsync()` для обновления этих финальных данных в `TestResultModel`.
    *   Затем вызывается `TestResultStorage.removeTestResultByTestIdAsync()` (или аналогичная функция).
    *   `TestResultStorage` находит полностью заполненный `TestResultModel` по ID теста, извлекает его из "картотеки" и возвращает адаптеру.
    *   Теперь этот готовый `TestResultModel` может быть передан компоненту, отвечающему за [Взаимодействие с API Test IT](06_взаимодействие_с_api_test_it_.md) для отправки.

## Что происходит "под капотом"?

`TestResultStorage` внутри использует обычную `Map` в Dart, где ключом является уникальный идентификатор теста (строка), а значением — объект `TestResultModel`.

```dart
// Упрощенное представление TestResultStorage
// Находится в: lib/src/storage/test_result_storage.dart

// Карта для хранения TestResultModel по ID теста
final Map<String, TestResultModel> _testResults = {};

// Блокировка для синхронизации доступа из разных тестов
final Lock _lock = Lock();

// Функция для получения уникального ID текущего теста
String _getTestId() {
  // Использует Invoker.current?.liveTest для получения деталей теста
  // и формирует уникальную строку (путь + имя)
  // ... реализация ...
  final liveTest = Invoker.current?.liveTest;
  final testId = '${liveTest?.suite.path}/${liveTest?.test.name}';
  return testId;
}

// Создает пустую запись для теста (если ее нет)
@internal
Future<void> createEmptyTestResultAsync() async {
  await _lock.synchronized(() { // Используем Lock для безопасности
    final testId = _getTestId();
    if (!_testResults.containsKey(testId)) {
      _testResults[testId] = TestResultModel(); // Добавляем пустую модель
    }
  });
}

// Обновляет основную информацию о тесте
@internal
Future<void> updateTestResultAsync(final TestResultModel testResult) async {
  await _lock.synchronized(() {
    final testId = _getTestId();
    // Находим существующую модель и обновляем ее поля
    _testResults.update(testId, (existingModel) {
      existingModel.outcome = testResult.outcome;
      existingModel.completedOn = testResult.completedOn;
      // ... обновление других полей ...
      return existingModel;
    }, ifAbsent: () => TestResultModel()); // На случай, если ее нет
  });
}

// Добавляет сообщение к тесту
@internal
Future<void> updateTestResultMessageAsync(final String message) async {
  await _lock.synchronized(() {
    final testId = _getTestId();
    _testResults.update(testId, (existingModel) {
      // Добавляем сообщение (возможно, к уже существующим)
      existingModel.message = '${existingModel.message ?? ''}$message\n';
      return existingModel;
    }, ifAbsent: () => TestResultModel());
  });
}

// Извлекает готовую модель из хранилища (удаляя ее оттуда)
@internal
Future<TestResultModel> removeTestResultByTestIdAsync(String testId) async {
  return await _lock.synchronized<TestResultModel>(() {
    // Находим и удаляем запись из карты
    final model = _testResults.remove(testId);
    // Возвращаем извлеченную модель (или пустую, если что-то пошло не так)
    return model ?? TestResultModel();
  });
}

// (Аналогичные функции существуют для createEmptyStepAsync, updateCurrentStepAsync,
// updateTestResultAttachmentsAsync, updateTestResultLinksAsync и т.д.)
```

**Пояснение:**
*   `_testResults` — это `Map`, где хранится вся информация.
*   `_getTestId()` — ключевая функция, которая позволяет узнать, для какого теста сейчас нужно обновить данные. Она использует внутренние механизмы фреймворка `flutter_test`, чтобы получить уникальное имя и путь текущего выполняемого теста.
*   Функции (`create...`, `update...`, `remove...`) используют `_getTestId()` для доступа к нужной записи в `_testResults`.
*   `_lock.synchronized()` используется для того, чтобы предотвратить проблемы, если несколько тестов попытаются одновременно изменить хранилище (хотя обычно тесты во Flutter выполняются последовательно).

Вот как можно представить этот процесс сбора данных с помощью диаграммы последовательности:

```mermaid
sequenceDiagram
    participant Test as Ваш Тест (tmsTest)
    participant Adapter as Адаптер (внутренняя логика)
    participant Storage as TestResultStorage
    participant Model as TestResultModel

    Test->>+Adapter: Запуск `tmsTest('Мой тест', ...)`
    Adapter->>+Storage: `createEmptyTestResultAsync()`
    Storage->>Storage: `testId = _getTestId()`
    Storage->>+Model: Создать `new TestResultModel()`
    Storage->>Storage: `_testResults[testId] = newModel`
    Model-->>-Storage: Создана
    Storage-->>-Adapter: Готово
    Adapter->>Test: Начать выполнение тела теста

    Test->>+Adapter: Вызов `step('Шаг 1', ...)`
    Adapter->>+Storage: `createEmptyStepAsync()`
    Storage->>Storage: Найти `model = _testResults[_getTestId()]`
    Storage->>Model: `model.steps.add(new StepModel())`
    Storage-->>-Adapter: Готово
    %% ... выполнение шага ... %%
    Adapter->>+Storage: `updateCurrentStepAsync(stepData)`
    Storage->>Storage: Найти `model = _testResults[_getTestId()]`
    Storage->>Model: Найти последний шаг и обновить `step.outcome = Passed`, `step.duration = ...`
    Storage-->>-Adapter: Шаг обновлен
    Adapter-->>-Test: Шаг завершен

    Test->>+Adapter: Вызов `addMessage('...')`
    Adapter->>+Storage: `updateTestResultMessageAsync('...')`
    Storage->>Storage: Найти `model = _testResults[_getTestId()]`
    Storage->>Model: `model.message += '...'`
    Storage-->>-Adapter: Сообщение добавлено
    Adapter-->>-Test: Готово

    %% ... тест завершается ... %%
    Test->>-Adapter: Тело теста завершено (Outcome: Passed)
    Adapter->>+Storage: `updateTestResultAsync(finalData)`
    Storage->>Storage: Найти `model = _testResults[_getTestId()]`
    Storage->>Model: `model.outcome = Passed`, `model.completedOn = ...`
    Storage-->>-Adapter: Результат обновлен
    Adapter->>+Storage: `removeTestResultByTestIdAsync(testId)`
    Storage->>Storage: `model = _testResults.remove(testId)`
    Storage-->>-Adapter: Вернуть `model` (полностью собранный)
    Adapter->>Adapter: Передать `model` для отправки в Test IT (см. Главу 6)

```

## Заключение

В этой главе мы погрузились во внутренний механизм сбора данных `adapters-flutter`. Мы узнали о двух ключевых компонентах:
*   **`TestResultModel`:** Структура данных ("анкета"), которая содержит всю информацию об одном конкретном тесте.
*   **`TestResultStorage`:** Временное хранилище ("картотека"), которое управляет экземплярами `TestResultModel` для всех выполняющихся тестов, позволяя постепенно накапливать данные (шаги, вложения, сообщения, результаты) перед отправкой.

Понимание того, как эти компоненты работают вместе, помогает увидеть полную картину: адаптер запускает тест, использует `TestResultStorage` для сбора всех деталей в `TestResultModel` по мере выполнения, а затем извлекает готовую "анкету" для отправки.

Теперь, когда мы знаем, *как* результаты собираются и *где* они хранятся, остался последний шаг: как этот собранный `TestResultModel` фактически отправляется в систему Test IT? Об этом мы поговорим в следующей, заключительной главе: [Взаимодействие с API Test IT](06_взаимодействие_с_api_test_it_.md).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)