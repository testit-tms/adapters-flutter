# Chapter 3: Управление шагами теста


В [предыдущей главе](02_управление_конфигурацией_.md) мы настроили наш адаптер, указав ему адрес Test IT и ключ доступа. Теперь он готов отправлять результаты тестов. Но что если сам тест довольно сложный и состоит из нескольких этапов? Просто увидеть "Пройден" или "Провален" для всего теста может быть недостаточно. Хотелось бы понимать, *какая именно часть* теста прошла успешно, а какая привела к ошибке.

Представьте, что вы печете пирог по сложному рецепту. Если пирог не получился, вам важно знать, на каком шаге вы ошиблись: неправильно смешали ингредиенты, передержали в духовке или что-то еще? Просто знать, что "пирог не удался", не очень полезно для исправления ошибок в будущем. Точно так же и с тестами.

**Управление шагами теста** решает именно эту проблему. Библиотека `adapters-flutter` предоставляет специальную функцию `step`, которая позволяет разбить ваш тест на логические части (шаги) и отслеживать результат выполнения каждого шага отдельно. Это как разбить ваш "рецепт" (тест) на пронумерованные пункты и отмечать галочкой каждый выполненный пункт.

## Знакомство с `step`: Добавляем детали в наши тесты

Функция `step` — это "обертка" для любого участка кода внутри вашего теста, который вы хотите выделить как отдельный этап. Она принимает два основных аргумента:

1.  `title` (String): Название шага, которое будет отображаться в отчете Test IT. Старайтесь давать шагам понятные имена.
2.  `body` (Function): Асинхронная функция (или обычная), содержащая код, который нужно выполнить в рамках этого шага.

Давайте посмотрим на пример. Допустим, у нас есть тест, который проверяет процесс входа пользователя:

```dart
// Тест без шагов
import 'package:adapters_flutter/adapters_flutter.dart';

void main() {
  tmsTest('Тест входа пользователя', () {
    // 1. Вводим логин
    print('Ввод логина...');
    expect(true, isTrue); // Допустим, это проверка поля логина

    // 2. Вводим пароль
    print('Ввод пароля...');
    expect(true, isTrue); // Допустим, это проверка поля пароля

    // 3. Нажимаем кнопку "Войти"
    print('Нажатие кнопки Войти...');
    expect(true, isTrue); // Допустим, это проверка успешного входа
  });
}
```

Если этот тест упадет, мы увидим только общую ошибку. Непонятно, на каком этапе она произошла. Теперь добавим шаги с помощью `step`:

```dart
// Тест с шагами
import 'package:adapters_flutter/adapters_flutter.dart';

void main() {
  tmsTest('Тест входа пользователя с шагами', () async { // Тело теста теперь async
    await step('Ввести логин', () { // Первый шаг
      print('Ввод логина...');
      expect(true, isTrue); // Проверка внутри шага
    });

    await step('Ввести пароль', () { // Второй шаг
      print('Ввод пароля...');
      expect(true, isTrue);
    });

    await step('Нажать кнопку "Войти" и проверить результат', () { // Третий шаг
      print('Нажатие кнопки Войти...');
      expect(true, isTrue);
    });
  });
}
```

**Что изменилось?**
*   Мы обернули каждый логический этап (ввод логина, ввод пароля, нажатие кнопки) в вызов `await step(...)`. Использование `await` здесь важно, если внутри шага есть асинхронные операции (что часто бывает в виджет-тестах) или если вы хотите, чтобы шаги выполнялись строго последовательно.
*   Теперь, если тест упадет, например, на этапе ввода пароля, адаптер запишет, что первый шаг ("Ввести логин") прошел успешно, а второй шаг ("Ввести пароль") провалился. Эта детальная информация отправится в Test IT.
*   Обратите внимание, что тело `tmsTest` теперь помечено как `async`, а перед `step` используется `await`. Это стандартный способ работы с асинхронными функциями в Dart.

## Вложенные шаги: Создаем иерархию

Иногда шаги сами по себе могут быть сложными и состоять из подзадач. Функция `step` позволяет создавать вложенные шаги — шаги внутри других шагов. Это похоже на создание подпунктов в инструкции.

```dart
// Тест с вложенными шагами
import 'package:adapters_flutter/adapters_flutter.dart';

void main() {
  tmsTest('Тест оформления заказа', () async {
    await step('Шаг 1: Добавить товар в корзину', () async { // Главный шаг 1
      await step('Найти товар "XYZ"', () { // Подшаг 1.1
        print('Ищем товар XYZ...');
        expect(true, isTrue);
      });
      await step('Нажать кнопку "Добавить в корзину"', () { // Подшаг 1.2
        print('Добавляем в корзину...');
        expect(true, isTrue);
      });
    });

    await step('Шаг 2: Перейти к оформлению', () { // Главный шаг 2
      print('Переходим к оформлению...');
      expect(true, isTrue);
    });

    // Представим, что этот шаг упал
    await step('Шаг 3: Заполнить данные доставки', () { // Главный шаг 3
       print('Заполняем адрес...');
       expect(false, isTrue); // Ошибка!
    });
  });
}

```

**Что произойдет при запуске этого теста?**
1.  Адаптер запишет, что "Шаг 1: Добавить товар в корзину" начался.
2.  Запишет, что подшаг "Найти товар 'XYZ'" выполнен успешно.
3.  Запишет, что подшаг "Нажать кнопку 'Добавить в корзину'" выполнен успешно.
4.  Отметит, что "Шаг 1: Добавить товар в корзину" завершился успешно (так как все его подшаги прошли).
5.  Запишет, что "Шаг 2: Перейти к оформлению" выполнен успешно.
6.  Запишет, что "Шаг 3: Заполнить данные доставки" начался, но завершился с ошибкой.
7.  Весь тест `tmsTest('Тест оформления заказа')` будет помечен как `Failed`, потому что один из его шагов упал.

В отчете Test IT вы увидите красивую древовидную структуру шагов, где будет ясно видно, какой шаг упал и какие шаги выполнялись до него.

## Шаги с возвращаемым значением

Функция `step` может не только выполнять действия, но и возвращать результат своей работы. Это полезно, если вам нужно получить какие-то данные из одного шага и использовать их в другом. Тип возвращаемого значения указывается как generic-параметр `T` у функции `step<T>`.

```dart
// Тест с шагом, возвращающим значение
import 'package:adapters_flutter/adapters_flutter.dart';

void main() {
  tmsTest('Тест API: Получить ID пользователя', () async {
    // Шаг, который получает и возвращает ID пользователя
    final String? userId = await step<String>('Получить ID пользователя из API', () {
      print('Выполняем запрос к API...');
      // Здесь был бы реальный вызов API
      final returnedId = 'user-123';
      expect(returnedId, isNotNull);
      return returnedId; // Возвращаем полученный ID
    });

    // Используем результат в следующем шаге
    await step('Проверить полученный ID', () {
      print('Проверяем ID: $userId');
      expect(userId, equals('user-123'));
    });
  });
}
```

**Как это работает?**
*   Мы указали `step<String>`, чтобы обозначить, что ожидаем строку в качестве результата.
*   Внутри `body` шага мы возвращаем значение `returnedId` с помощью `return`.
*   Результат выполнения `step` присваивается переменной `userId`.
*   Если шаг упадет (например, проверка `expect` не пройдет или в `body` возникнет исключение), `step` перехватит ошибку, пометит шаг как `Failed` и пробросит исключение дальше (или вернет `null`, если тип допускает `null`).

## Как это выглядит в Test IT?

Когда вы используете `step` и `tmsTest` / `tmsTestWidgets`, адаптер собирает информацию о каждом шаге:
*   Название (`title`)
*   Описание (`description`, необязательный параметр `step`)
*   Время начала и окончания
*   Длительность
*   Результат (`Passed` или `Failed`)
*   Вложенные шаги (если есть)

Вся эта структура передается в Test IT и отображается на странице результатов тест-поинта в виде иерархического списка. Это позволяет очень наглядно видеть ход выполнения теста.

```
Тест входа пользователя с шагами (Passed)
  └─ Шаг: Ввести логин (Passed)
  └─ Шаг: Ввести пароль (Passed)
  └─ Шаг: Нажать кнопку "Войти" и проверить результат (Passed)

Тест оформления заказа (Failed)
  └─ Шаг: Шаг 1: Добавить товар в корзину (Passed)
  |    └─ Шаг: Найти товар "XYZ" (Passed)
  |    └─ Шаг: Нажать кнопку "Добавить в корзину" (Passed)
  └─ Шаг: Шаг 2: Перейти к оформлению (Passed)
  └─ Шаг: Шаг 3: Заполнить данные доставки (Failed) 💥
```

## Что происходит "под капотом"? Запись шагов

Когда вызывается функция `step`, адаптер выполняет следующие действия:

1.  **Начало шага:** Адаптер понимает, что начался новый шаг. Он находит текущий выполняющийся тест и "готовит место" для записи информации об этом шаге. Если это вложенный шаг, он находит родительский шаг и добавляет новый шаг к нему.
2.  **Засечка времени:** Запоминается время начала выполнения шага.
3.  **Выполнение кода:** Выполняется ваш код, переданный в `body` функции `step`.
4.  **Перехват результата:** Адаптер следит за выполнением:
    *   Если код в `body` завершился успешно, шаг помечается как `Passed`. Если `body` вернуло значение, оно сохраняется.
    *   Если во время выполнения `body` произошло исключение (например, `expect` провалился или возникла другая ошибка), адаптер перехватывает это исключение, помечает шаг как `Failed` и сохраняет информацию об ошибке. Затем исключение пробрасывается дальше, чтобы весь тест `tmsTest` тоже был помечен как `Failed`.
5.  **Запись информации:** Записывается время окончания, вычисляется длительность, сохраняется результат (`Passed`/`Failed`), название, описание и другая информация о шаге.
6.  **Сохранение:** Эта информация о шаге сохраняется во временном хранилище как часть данных о текущем тесте. Позже, после завершения всего теста, вся структура (включая все шаги) будет отправлена в Test IT.

Упрощенная схема выполнения `step`:

```mermaid
sequenceDiagram
    participant TC as Ваш Тестовый Код
    participant SM as StepManager (step функция)
    participant TRS as TestResultStorage (Хранилище)
    participant Body as Код внутри step (body)

    TC->>+SM: Вызвать step('Название шага', body)
    SM->>+TRS: Начать новый шаг (createEmptyStepAsync)
    TRS-->>-SM: Место для шага создано
    SM->>+Body: Выполнить body()
    alt Успешное выполнение
        Body-->>-SM: Вернуть результат (если есть)
        SM->>SM: Отметить шаг как Passed
    else Ошибка выполнения
        Body-->>-SM: Выбросить исключение
        SM->>SM: Перехватить исключение, Отметить шаг как Failed
    end
    SM->>+TRS: Записать детали шага (название, время, результат) (updateCurrentStepAsync)
    TRS-->>-SM: Детали шага сохранены
    alt Успешное выполнение
       SM-->>-TC: Вернуть результат шага (если был)
    else Ошибка выполнения
       SM-->>-TC: Пробросить исключение дальше
    end

```

### Немного о коде

Основная логика функции `step` находится в файле `lib/src/manager/step_manager.dart`.

```dart
// Упрощенный пример из lib/src/manager/step_manager.dart

import 'package:adapters_flutter/src/storage/test_result_storage.dart';
// ...другие импорты...

/// Выполняет [body] как шаг теста с [title] и [description].
FutureOr<T?> step<T>(final String title, final FutureOr<T?> Function() body,
    {final String? description}) async {
  T? result; // Переменная для хранения результата body

  // Проверяем конфигурацию (нужно ли вообще записывать шаги?)
  final config = await createConfigOnceAsync(); // См. главу 2

  // Если интеграция с Test IT включена
  if ((config.testIt ?? true)) {
    // 1. Готовим место для записи шага в хранилище
    await createEmptyStepAsync(); // См. главу 5

    // Создаем локальную модель для информации о шаге
    final localStep = AutoTestStepResultsModel();
    final startedOn = DateTime.now(); // Засекаем время начала

    try {
      // 3. Выполняем ваш код
      result = await body.call();
      localStep.outcome = Outcome.passed; // Если нет ошибок - Успех
    } catch (_) {
      // 4. Если произошла ошибка
      localStep.outcome = Outcome.failed; // Помечаем как Провал
      rethrow; // Пробрасываем ошибку дальше, чтобы тест упал
    } finally {
      // 5. Этот блок выполнится в любом случае (успех или ошибка)
      final completedOn = DateTime.now(); // Засекаем время окончания

      // Записываем все данные о шаге
      localStep.completedOn = completedOn;
      localStep.description = description ?? ''; // Описание (если есть)
      localStep.duration = completedOn.difference(startedOn).inMilliseconds; // Длительность
      localStep.startedOn = startedOn;
      localStep.title = title; // Название

      // 6. Обновляем/сохраняем данные этого шага в хранилище
      await updateCurrentStepAsync(localStep); // См. главу 5
    }
  } else {
    // Если интеграция отключена, просто выполняем body
    result = await body.call();
  }

  // Возвращаем результат выполнения body (если он был)
  return result;
}

```

**Пояснение:**
*   Функция `step` сначала проверяет конфигурацию – нужно ли вообще взаимодействовать с Test IT.
*   `createEmptyStepAsync()` и `updateCurrentStepAsync()` – это функции из [Хранилище и модель результата теста](05_хранилище_и_модель_результата_теста_.md), которые управляют записью данных о шагах. `createEmptyStepAsync` находит текущий тест (или родительский шаг) и добавляет к нему пустой "слот" для нового шага.
*   Код пользователя (`body.call()`) выполняется внутри блока `try...catch`, чтобы можно было отловить результат (успех или провал).
*   В блоке `finally` (который выполняется всегда) происходит запись всех метаданных шага (название, время, результат) с помощью `updateCurrentStepAsync`.
*   Если произошла ошибка, она пробрасывается дальше (`rethrow`), чтобы стандартный механизм тестов Flutter тоже зафиксировал падение.

Таким образом, `step` элегантно оборачивает выполнение вашего кода, собирая при этом всю необходимую информацию для детального отчета в Test IT.

## Заключение

В этой главе мы научились использовать функцию `step` для разделения наших тестов на логические этапы. Мы увидели, как это помогает создавать более подробные и понятные отчеты в Test IT, показывая не только общий результат теста, но и статус выполнения каждого отдельного шага, включая вложенные. Это значительно упрощает анализ упавших тестов и отладку.

Теперь наши отчеты содержат структуру шагов. Но можно ли добавить еще больше контекста? Например, прикрепить скриншот к упавшему шагу или добавить ссылку на связанную задачу? Да, можно! В следующей главе, [Функции обогащения результатов](04_функции_обогащения_результатов_.md), мы рассмотрим, как добавлять в отчеты ссылки, сообщения и файлы (аттачменты).

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)